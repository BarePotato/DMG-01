<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>DMG-01: How to Emulate a Game Boy</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="architecture_overview.html"><strong aria-hidden="true">2.</strong> Architecture Overview</a></li><li><a href="cpu/introduction.html"><strong aria-hidden="true">3.</strong> CPU</a></li><li><ol class="section"><li><a href="cpu/registers.html"><strong aria-hidden="true">3.1.</strong> CPU Registers</a></li><li><a href="cpu/register_data_instructions.html"><strong aria-hidden="true">3.2.</strong> Instructions on Register Data</a></li></ol></li><li><a href="appendix/index.html"><strong aria-hidden="true">4.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix/numbers.html"><strong aria-hidden="true">4.1.</strong> Numbers</a></li><li><a href="appendix/number_notations.html"><strong aria-hidden="true">4.2.</strong> Number Notations</a></li><li><a href="appendix/bit_manipulation.html"><strong aria-hidden="true">4.3.</strong> Bit Manipulation</a></li><li><a href="appendix/resources.html"><strong aria-hidden="true">4.4.</strong> Resources</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">DMG-01: How to Emulate a Game Boy</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#introduction" id="introduction"><h1>Introduction</h1></a>
<p>If you really want to know how a particular computer works, there's no better way to learn than by emulating that computer. In this book, we'll be looking at one of the most loved computers of all time, Nintendo's Game Boy. We'll be going through the process from nothing and building the Game Boy up piece by piece. In the process not only will we learn more about the Game Boy itself, but we'll also get a good glimpse into how computers work in general as well as how to build emulators for other computer systems.</p>
<a class="header" href="#what-you-need-to-know" id="what-you-need-to-know"><h2>What You Need to Know</h2></a>
<p>We'll be assuming only basic programming knowledge and basic knowledge of the terminal. If you've programmed in almost any other language before you should be good to go. The particular language we'll be using is the <a href="https://www.rust-lang.org">Rust programming language</a>, but if you've never used Rust, don't worry; we'll be taking things slow, and I'll do my best to link to relevant learning material as things come up. If you want to get a head start on learning the basics of Rust, the amazing <a href="https://doc.rust-lang.org/book/second-edition/index.html">Rust book</a> is a great way to learn.</p>
<p>If you've already build emulators before, and are just looking for a reference specific to the Game Boy, you might find this book to be too detailed. I recommend the <a href="http://bgb.bircd.org/pandocs.htm">Pan Docs</a> as a great place to quickly learn the nity-grity of the Game Boy. You'll find even more resources in the <a href="./appendix/resources.html">resources guide</a>.</p>
<a class="header" href="#why-rust" id="why-rust"><h2>Why Rust?</h2></a>
<p>For many emulation projects performance is a key consideration. This means that emulators are often written in low-level languages that allow the programmer to easily write performant code. While our Game Boy emulator could be written in other languages like JavaScript or Python, it's best to use a language that would be appropriate for more resource intensive emulation (e.g. Sony's PlayStation 2 or Nintendo's Wii) so these skills can be used for future emulation projects. Rust fits the bill perfectly here.</p>
<p>While there are other languages that allow the performance needed for emulation like C and C++, Rust has the added bonus of being much more beginner friendly than C or C++. Unlike these older languages Rust has a solid package manager, testing framework and build tool that will feel familiar to users of more modern languages. Rust's community is also fantastic and generally very helpful.</p>
<p>Finally, Rust also has a great cross platform story - we'll be focusing on web and on desktop, but in the future, we might also be able to bring our emualtor to mobile platforms and embedded devices!</p>
<a class="header" href="#setup" id="setup"><h2>Setup</h2></a>
<p>In order to get started, you'll only need your favorite text editor and Rust related tooling. Follow the instructions <a href="https://www.rust-lang.org/en-US/install.html">on the Rust website</a> for how to install the rustup tool which gives you access to the Rust compiler, the Rust build tool and package manager called Cargo, as well as some other tools that we'll be using later on in our journey.</p>
<p>If you've successfully been able to install Rust you can create a new project by running the following command in your terminal:</p>
<pre><code class="language-bash">cargo new emulator
</code></pre>
<p>Navigate into your project's directory and have a look around. To run your project run the following:</p>
<pre><code class="language-bash">cargo run
</code></pre>
<p>You're all good to go! Let's get emulating!</p>
<a class="header" href="#architecture-overview" id="architecture-overview"><h1>Architecture Overview</h1></a>
<p>Before we can begin we need to have a basic understanding of what is needed to build a Game Boy emulator. This starts by having a basic understanding of the Game Boy computer architecture. If you're already familiar with the very basics of CPUs, computer memory and I/O devices, you can skip to the next page.</p>
<a class="header" href="#at-a-high-level" id="at-a-high-level"><h2>At a High Level</h2></a>
<p>The Gameboy can be thought to contain the following pieces:</p>
<a class="header" href="#cpu-central-processing-unit" id="cpu-central-processing-unit"><h4>CPU (Central Processing Unit)</h4></a>
<p>The CPU is the &quot;brains&quot; of a computer. The CPU is responsible for the following:</p>
<ul>
<li>Executing instructions defined by the game the Game Boy is running</li>
<li>Reading and writting to memory</li>
<li>Reacting to &quot;events&quot; (known as interrupts) that come from the I/O (input/output) hardware such as the screen and the gamepad controls</li>
<li>Keeping track of very small pieces of data in &quot;registers&quot; that it manipulates when it runs instructions</li>
</ul>
<a class="header" href="#ram-random-access-memory" id="ram-random-access-memory"><h4>RAM (Random Access Memory)</h4></a>
<p>This is the piece of hardware that allows the Game Boy to remember data while it is running. Without the RAM, the Gameboy's CPU could still execute instructions and keep track of small pieces of data in its registers, but if the data no longer fits in its registers, the CPU would have to throw it away.</p>
<a class="header" href="#rom-read-only-memory" id="rom-read-only-memory"><h3>ROM (Read Only Memory)</h3></a>
<p>This is memory that has been &quot;hardcoded&quot; into the machine (hence it being read only). This memory is used to tell the machine how to set itself up (a.k.a bootstrap) to be able to begin accepting instructions as well as to play the <a href="https://www.youtube.com/watch?v=ClJWTR_lCL4">iconic splash screen</a> on boot.</p>
<p>Game cartridges are also known as ROMs as they are mostly read only memory as well.</p>
<a class="header" href="#io-inputoutput" id="io-inputoutput"><h3>I/O (Input/Output)</h3></a>
<p>The Gameboy has several pieces of I/O hardware:</p>
<ul>
<li>The screen,</li>
<li>Hardware dedicated to playing sounds,</li>
<li>A gamepad that the player uses to interact with the game through pushing various buttons.</li>
</ul>
<p>We'll discuss how the CPU can interface with this hardware much later in the book.</p>
<blockquote>
<p><strong>Learn More</strong></p>
<p>If you're interested in learning more about how computers work all the way down to the electrical level, I suggest watching Ben Eater's series on <a href="https://www.youtube.com/user/eaterbc">making an 8-bit Breadboard Computer</a>. Ben does an absolutely wonderful job of explaining how CPUs, RAM, ROM and even I/O devices are built from the ground up!</p>
</blockquote>
<p>Now that we have a small overview of the pieces we'll be talking about, let's take a closer look at the CPU!</p>
<a class="header" href="#cpu" id="cpu"><h1>CPU</h1></a>
<a class="header" href="#cpu-registers" id="cpu-registers"><h1>CPU Registers</h1></a>
<p>In the previous chapter we outlined some of things that the CPU is responsible for. In this chapter we'll be focusing on just one of them: saving small amounts of data into registers.</p>
<a class="header" href="#overview" id="overview"><h2>Overview</h2></a>
<p>The Game Boy's CPU is a custom chip made just for the Game Boy. The chip is extremely similar to the <a href="https://en.wikipedia.org/wiki/Intel_8080">Intel 8080</a> which is itself similar to the <a href="https://en.wikipedia.org/wiki/Zilog_Z80">Zilog Z80</a>. While the Intel 8080 and Zilog Z80 were used in many different computers in the 70s and 80s, the chip inside the Game Boy was just used for the Game Boy. Most of what's true about how the 8080 and Z80 work is also true of the Game Boy's chip. We won't go into details on how exactly they differ, but it's important to be aware that while they're similar to the Game Boy's chip, they're not exactly the same.</p>
<a class="header" href="#registers" id="registers"><h2>Registers</h2></a>
<p>The CPU is composed of 8 different &quot;registers&quot;. Registers are responsible for holding on to little pieces of data that the CPU can manipulate when it executes various instructions. The Game Boy's CPU is an 8-Bit CPU, meaning that each of its registers can hold 8 bits (a.k.a 1 byte) of data. The CPU has 8 different registers labled as &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;h&quot;, &quot;l&quot;.</p>
<p>Let's get started building our CPU by specing out the registers in code:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Registers {
  a: u8,
  b: u8,
  c: u8,
  d: u8,
  e: u8,
  f: u8,
  h: u8,
  l: u8,
}
#}</code></pre></pre>
<p>We use the type <code>u8</code> for our registers. <code>u8</code> are 8-bit unsigned integers. For a refresher on how numbers are stored in computers, checkout the <a href="./appendix/numbers.html">guide on numbers</a>.</p>
<p>While the CPU only has 8 bit registers, there are instructions that allow the game to read and write 16 bits (i.e. 2 bytes) at the same time (denoted as <code>u16</code> in Rust - a 16 bit unsigned integer). Therefore, we'll need the ability to read an write these &quot;virtual&quot; 16 bit registers. These registers are refered to as &quot;af&quot; (&quot;a&quot; and &quot;f&quot; combined), &quot;bc&quot; (&quot;b&quot; and &quot;c&quot; combined), &quot;de&quot; (&quot;d&quot; and &quot;e&quot; combinded), and finally &quot;hl&quot; (&quot;h&quot; and &quot;l&quot; combined). Let's implement &quot;bc&quot;:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Registers {
  fn get_bc(&amp;self) -&gt; u16 {
    (self.b as u16) &lt;&lt; 8
    | self.c as u16
  }

  fn set_bc(&amp;mut self, value: u16) {
    self.b = ((value &amp; 0xFF00) &gt;&gt; 8) as u8;
    self.c = (value &amp; 0xFF) as u8;
  }
}
#}</code></pre></pre>
<p>Here we see our first instance of &quot;bit manipulation&quot; through the use of four bitwise operators: &quot;&gt;&gt;&quot;, &quot;&lt;&lt;&quot;, &quot;&amp;&quot;, and &quot;|&quot;. If you're unfamiliar with or feel a bit rusty using these types of operators, check out the <a href="./appendix/bit_manipulation.html">guide on bit manipulation</a>.</p>
<p>For reading the &quot;bc&quot; register we first treat the &quot;b&quot; register as a <code>u16</code> (this effectively just adds a byte of all 0s to the most significant position of the number). We then shift the &quot;b&quot; register 8 positions so that it's occupying the most signficant byte position. Finally, we bitwise OR the &quot;c&quot; register. The result is a two byte number with the contents of &quot;b&quot; in the most signficant byte position and the contents of &quot;c&quot; in the least signficant byte position.</p>
<a class="header" href="#flags-register" id="flags-register"><h2>Flags Register</h2></a>
<p>We're almost done with our registers, but there's one thing we way we can improve our registers for use later. The &quot;f&quot; register is a special register called the &quot;flags&quot; register. The lower four bits of the register are <em>always</em> 0s and the CPU automatically writes to the upper four bits when certain things happen. In other words, the CPU &quot;flags&quot; certain states. We won't go into the specific meanings of the flags just yet, but for now just know that they have the following names and positions:</p>
<ul>
<li>Bit 7: &quot;zero&quot;</li>
<li>Bit 6: &quot;subtraction&quot;</li>
<li>Bit 5: &quot;half carry&quot;</li>
<li>Bit 4: &quot;carry&quot;</li>
</ul>
<p>Here's a diagram of the flags register:</p>
<pre><code>   ┌-&gt; Carry
 ┌-+&gt; Subtraction
 | |
1111 0000
| |
└-+&gt; Zero
  └-&gt; Half Carry
</code></pre>
<p>So while we could continue modeling our flags register as a simple 8-bit number (after all, that's all it is in reality), it might be less error prone to explicitly model the fact that the upper 4 bits (a.k.a the upper &quot;nibble&quot;) has specific meaning and the lower 4 bits (a.k.a the lower &quot;nibble&quot;) must always be zeros.</p>
<p>For this reason we'll make a struct called the <code>FlagsRegister</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct FlagsRegister {
    zero: bool,
    subtract: bool,
    half_carry: bool,
    carry: bool
}
#}</code></pre></pre>
<p>Since we might need to look at this register as an 8-bit number, we can implement some traits from the standard library that make this easy:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
const ZERO_FLAG_BYTE_POSITION: u8 = 7;
const SUBTRACT_FLAG_BYTE_POSITION: u8 = 6;
const HALF_CARRY_FLAG_BYTE_POSITION: u8 = 5;
const CARRY_FLAG_BYTE_POSITION: u8 = 4;

impl std::convert::From&lt;FlagsRegister&gt; for u8  {
    fn from(flag: FlagsRegister) -&gt; u8 {
        (if flag.zero       { 1 } else { 0 }) &lt;&lt; ZERO_FLAG_BYTE_POSITION |
        (if flag.subtract   { 1 } else { 0 }) &lt;&lt; SUBTRACT_FLAG_BYTE_POSITION |
        (if flag.half_carry { 1 } else { 0 }) &lt;&lt; HALF_CARRY_FLAG_BYTE_POSITION |
        (if flag.carry      { 1 } else { 0 }) &lt;&lt; CARRY_FLAG_BYTE_POSITION
    }
}

impl std::convert::From&lt;u8&gt; for FlagsRegister {
    fn from(byte: u8) -&gt; Self {
        let zero = ((byte &gt;&gt; ZERO_FLAG_BYTE_POSITION) &amp; 0b1) != 0;
        let subtract = ((byte &gt;&gt; SUBTRACT_FLAG_BYTE_POSITION) &amp; 0b1) != 0;
        let half_carry = ((byte &gt;&gt; HALF_CARRY_FLAG_BYTE_POSITION) &amp; 0b1) != 0;
        let carry = ((byte &gt;&gt; CARRY_FLAG_BYTE_POSITION) &amp; 0b1) != 0;

        FlagsRegister {
            zero,
            subtract,
            half_carry,
            carry
        }
    }
}
#}</code></pre></pre>
<p>The <code>std::convert::From</code> trait allows us to easily convert our FlagsRegister from a <code>u8</code> and back.</p>
<p>Now that we have our special <code>FlagsRegister</code>, we can replace the <code>u8</code> in our <code>Registers</code> struct's <code>f</code> field.</p>
<p>And that's it! We have all the functionality we need for our registers. Next we'll be looking at different instructions for manipulating the registers.</p>
<a class="header" href="#instructions-on-register-data" id="instructions-on-register-data"><h1>Instructions on Register Data</h1></a>
<p>The first instructions we'll be examining are instructions that just operate on and manipulate register data.</p>
<a class="header" href="#add" id="add"><h2>ADD</h2></a>
<p>We'll start by looking closely at how the <code>ADD</code> instructions work. This is a simple instruction that adds specific register's contents to the A register's contents. Once we know how this instruction works, it won't be much work to extend the CPU to support all other instructions that just operate on register data.</p>
<a class="header" href="#definition" id="definition"><h3>Definition</h3></a>
<p>First we need to define the instruction. We'll get into how the game code actually encodes instructions and where the instructions come from later on. For now we're just focusing on the instruction itself and how it affects the CPU registers.</p>
<p>The first thing to do is to define an enum called <code>Instruction</code>. This enum will be the central place where all of our instructions will be defined. Our <code>ADD</code> instruction needs to include information on which register they're targeting so we'll make sure to include it by associating the instruction with <code>ArithmeticTarget</code> enum that specifies the target register. <code>ADD</code> can target all of the 8 bit registers except f.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Instruction {
  ADD(ArithmeticTarget),
}

enum ArithmeticTarget {
  A, B, C, D, E, H, L,
}
#}</code></pre></pre>
<a class="header" href="#executing-the-instruction" id="executing-the-instruction"><h3>Executing the Instruction</h3></a>
<p>Ok, now that we have ths instruction, we'll need a way to execute it. Let's create a method on CPU that takes an instruction and executes it. This method will take a mutable reference to the CPU since instructions always mutate the CPU's state. The method will also take the instruction it will execute. We'll pattern match on the instruction and the target register, and then we'll do the appropriate action according to the instruction and the register:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl CPU {
  ...
  fn execute(&amp;mut self, instruction: Instruction) {
    match instruction {
      Instruction::ADD(target) =&gt; {
        match target {
          ArithmeticTarget::C =&gt; {
            // TODO: implement ADD on register C
          }
          _ =&gt; // TODO: support more targets
        }
      }
      _ =&gt; // TODO: support more instructions
    }
  }
  ...
}
#}</code></pre></pre>
<p>We now have the boiler plate for figuring out which instruction and which target register. Let's see now what we have to do to the actual CPU. The steps for <code>ADD</code> for 8 bit target registers are the following:</p>
<ul>
<li>Read the current value from the target register</li>
<li>Add the value to the value in the A register making sure to handle overflow properly</li>
<li>Update the flags register</li>
<li>Write the updated value to the A register</li>
</ul>
<p>Let's implement it with C as the target register:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
...
    match instruction {
      Instruction::ADD(target) =&gt; {
        match target {
          ArithmeticTarget::C =&gt; {
            let value = self.registers.c;
            let new_value = self.add(value);
            self.registers.a = new_value;
          }
          _ =&gt; // TODO: support more targets
        }
        _ =&gt; // TODO: support more instructions
      }
    }
...
  fn add(&amp;mut self, value: u8) {
    let (new_value, did_overflow) = self.registers.a.overflowing_add(value);
    // TODO: set flags
    new_value
  }
...
#}</code></pre></pre>
<p>Notice that we use the <code>overflowing_add</code> method on our 8 bit value instead of <code>+</code>. This is because <code>+</code> panics in development when the result of the addition overflows. Rust forces us to be explicit about the behaivor we want, we chose <code>overflowing_add</code> because it properly overflows the value, and it informs us if the addition actually resulted in an overflow or not. This will be important information for when we update the flags register.</p>
<a class="header" href="#setting-flags" id="setting-flags"><h3>Setting Flags</h3></a>
<p>There are four flags defined on the flags register:</p>
<ul>
<li>
<p>Zero: set to true if the result of the operation is equal to 0.</p>
</li>
<li>
<p>Subtract: set to true if the operation was a subtraction.</p>
</li>
<li>
<p>Carry: set to true if the operation resulted in an overflow.</p>
</li>
<li>
<p>Half Carry: set to true if there is an overflow from the lower nibble (a.k.a the lower four bits) to the upper nibble (a.k.a the upper four bits). Let's take a look at some examples of what this means. In the following diagram, we have the byte 143 in binary (0b1000_1111). We then add 0b1 to the number. Notice how the 1 from the lower nibble is carried to the upper nibble. You should already be familiar with carries from elemetry arithmetic. Whenever there's not enough room for a number in a particular digit's place, we carry over to the next digits place.</p>
<pre><code>      lower nibble            lower nibble
         ┌--┐                    ┌--┐
    1000 1111  +   1   ==   1001 0000
    └--┘                    └--┘
upper nibble            upper nibble
</code></pre>
<p>If this happens when adding our values, we set the half_carry flag to true. We can test for this by masking out the upper nibble of both the A register and the value we're adding and testing if this value is greater than 0xF.</p>
</li>
</ul>
<p>So let's take a look at the code:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
...
  fn add(&amp;mut self, value: u8) {
    let (new_value, did_overflow) = self.registers.a.overflowing_add(value);
    self.registers.f.zero = new_value == 0;
    self.registers.f.subtract = false;
    self.registers.f.carry = did_overflow;
    // Half Carry is set if adding the lower nibbles of the value and register A
    // together result in a value bigger than 0xF. If the result is larger than 0xF
    // than the addition caused a carry from the lower nibble to the upper nibble.
    self.registers.f.half_carry = (self.registers.a &amp; 0xF) + (value &amp; 0xF) &gt; 0xF;
    new_value
  }
...
#}</code></pre></pre>
<a class="header" href="#how-do-we-know" id="how-do-we-know"><h2>How Do We Know?</h2></a>
<p>Yout might be wondering, &quot;how do we know what to do given a certain the instruction&quot;. The short answer is that this is just how the chip was specified  and manufactured to worked. We know this because people have either read the original user's manual for the Game Boy's CPU chip (known as a &quot;data sheet&quot;),or they've written test programs for the chip that call specific instructions and see what happens. Luckily you don't need to do this. You can find descriptions of all the instructions <a href="TODO">in the instruction guide</a>.</p>
<blockquote>
<p><em>Side Note</em></p>
<p>Most CPU instructions that deal with register data manipulate that data through various bitwise operations. If the likes of logical shifts and bitwise ands aren't super clear to you, check out the <a href="./appendix/bit_manipulation.html">guide on bit manipulation</a>.</p>
</blockquote>
<p>What are the other types of instructions that act on register data?</p>
<ul>
<li>ADC (add with carry) - just like ADD except that the value of the carry flag is also added to the number</li>
<li>SUB (subtract) - subtract the value stored in a specific register with the value in the A register</li>
<li>SBC (subtract with carry) - just like ADD except that the value of the carry flag is also subtracted from the number</li>
<li>AND (logical and) - do a bitwise and on the value in a specific register and the value in the A register</li>
<li>OR (logical or) - do a bitwise or on the value in a specific register and the value in the A register</li>
<li>XOR (logical xor) - do a bitwise xor on the value in a specific register and the value in the A register</li>
<li>CP (compare) - just like SUB except the result of the subtraction is not stored back into A</li>
<li>INC (increment) - increment the value in a specific register by 1</li>
<li>DEC (decrement) - decrement the value in a specific register by 1</li>
<li>CCF (complement carry flag) - toggle the value of the carry flag</li>
<li>SCF (set carry flag) - set the carry flag to true</li>
<li>RRA (rotate right A register) - bit rotate A register right through the carry flag</li>
<li>RLA (rotate left A register) - bit rotate A register left through the carry flag</li>
<li>RRCA (rotate right A register) - bit rotate A register right (not through the carry flag)</li>
<li>RRLA (rotate left A register) - bit rotate A register left (not through the carry flag)</li>
<li>CPL (complement) - toggle every bit of a specific register</li>
<li>BIT (bit test) - test to see if a specific bit of a specific register is set</li>
<li>RESET (bit reset) - set a specific bit of a specific register to 0</li>
<li>SET (bit set) - set a specific bit of a specific register to 1</li>
<li>SRL (shift right logical) - bit shift a specific register right by 1</li>
<li>RR (rotate right) - bit rotate a specific register right by 1 through the carry flag</li>
<li>RL (rotate left) - bit rotate a specific register left by 1 through the carry flag</li>
<li>SRA (shift right arithmetic) - arithmetic shift a specific register right by 1</li>
<li>SLA (shift left arithmetic) - arithmetic shift a specific register left by 1</li>
<li>SWAP (swap nibbles) - switch upper and lower nibble of a specific register</li>
</ul>
<p>Reading through the guide on instructions, should give you enough information to implement all the instructions yourself.</p>
<p>Next, we'll be looking at how the CPU keeps track of which instructions to execute as well as different types of instructions that can change where we are in a particular program.</p>
<a class="header" href="#appendix" id="appendix"><h1>Appendix</h1></a>
<a class="header" href="#numbers-in-computers" id="numbers-in-computers"><h1>Numbers in Computers</h1></a>
<p>In this guide, we'll look at how numbers are stored in the Gameboy's CPU, RAM, and ROM. In this guide we'll be using different types of number notations: binary, decimal and hexadecimal. If you're unfamiliar with these different ways of writing numbers, check out our <a href="./number_notations.html">guide on number notations</a>.</p>
<a class="header" href="#bits" id="bits"><h2>Bits</h2></a>
<p>At a very basic level, computers can only read and write two different values that we'll call 1 and 0. This piece of data is called a bit. Computer memory is really just a long array of bits that the computer can read or write.</p>
<blockquote>
<p><strong>Learn More</strong></p>
<p>Computers normally represent bits as either one voltage (e.g., five volts) or as some other, typically lower, voltage (e.g., zero volts). Again, a great resource for learning about how computers actually deal with bits, check out Ben Eater's series on <a href="https://www.youtube.com/user/eaterbc">making an 8-bit Breadboard Computer</a>.</p>
</blockquote>
<p>Bits can represent only two different values 0 or 1. If we want to numbers larger than one we need to compose bits together. To get to three for instance we would write 0b11. The total count of numbers we can represent is equal to 2^(# of bits). So one bit can represent 2^1 a.k.a two numbers and 7 bits can represent 2^7 a.k.a 128 numbers.</p>
<p>Since being able to manipulate numbers larger than 1 is pretty useful, we normally talk about and the computer typically reads and writes bits in large chunks called bytes.</p>
<a class="header" href="#bytes" id="bytes"><h3>Bytes</h3></a>
<p>Bytes are defined as a collection of 8 bits. Our Gameboy, as an 8-bit machine, typically deals with one byte at a time and each compartment in memory stores one byte. However, the Game Boy also has 16-bit instructions which act on two bytes at a time. A byte can represent numbers 2^8 a.k.a 256 numbers (0 to 255) while 8 bytes (composed of 64 bits) and can represent 2^64 a.k.a 9,223,372,036,854,775,808 numbers (0 to 9,223,372,036,854,775,807).</p>
<blockquote>
<p><strong>Learn More</strong></p>
<p>Some times we'll actually only deal with half a byte (i.e., 4 bits) at a time. This is usually referred to as a &quot;nibble&quot;.</p>
</blockquote>
<p>Since writing out bytes in binary can be quite tedious, we normally write out bytes in hexadecimal notation: So while we could write out the byte representing the number 134 as &quot;0b10000110&quot; we typically write it as &quot;0x86&quot;. These two notations specify the same number, &quot;0x86&quot; is just shorter so it's more often used.</p>
<p>When disucssing numbers composed of multiple bytes, for example 0xFFA1 (composed of three bytes), we'll often need to talk about which byte is &quot;most significant&quot; (MSB - most significant byte) and which is &quot;least significant&quot; (LSB - least significant byte). Going back to math class, you may remember that when writing numbers like &quot;178&quot;, the digit on the right (i.e., the &quot;8&quot;) is the least sigificant, it adds the least amount to the total sum of the number (just eight) while the digit on the left (i.e., the &quot;1&quot;) is the most significant since it adds the most to the sum of the number (one hundred!). Bytes work the same way - in 0xFFA1, 0xFF is the most significant byte and 0xA1 is the least significant.</p>
<a class="header" href="#endianess" id="endianess"><h2>Endianess</h2></a>
<p>Let's take the example of two bytes sitting next to each other in memory: first at address 0 there is 0xFF and then at address 1 there is 0x16. If we want to read these two bytes together as a 16 bit number, should it be read as 0xFF16 or as 0x16FF? Even if one way or the other makes more sense to you, the answer is: it depends on the machine. In the case of the Game Boy the order is 0xFF16 - in other words the least significant byte is first in memory. This scheme is known as little-endian and its opposite is known as big-endian.</p>
<a class="header" href="#signed-numbers" id="signed-numbers"><h3>Signed Numbers</h3></a>
<p>Ok so we know how to conceivably represent any number from 0 to some very large positive number. We can just keep adding bytes until we have enough to represent our number. But what about negative numbers? Well one way we could chose to do it (and the way the Game Boy does it) is using something called the &quot;two's complement&quot;.</p>
<p>Let's say we have the number 0b00111011 a.k.a. 59 and we want to represent -59 instead. In two's complement, we do the following:</p>
<ul>
<li>Invert every digit - 1s become 0s and 0s become 1s
<ul>
<li>0b00111011 becomes 0b11000100</li>
</ul>
</li>
<li>Add 1 to the number
<ul>
<li>0b11000100 becomes 0b11000101</li>
</ul>
</li>
</ul>
<p>So -59 is 0b11000101. But wait is 0b11000101 already 197? Yes it is! Whether we chose to interpret a byte as a number from 0 to 255 or as two's complement number capable of representing -128 to 127 is up to programmer! Interpreting a number as only positive means it is &quot;unsigned&quot; and interpeting as being possibly negative with two's complement means it is &quot;signed&quot;.</p>
<a class="header" href="#overflow-and-underflow" id="overflow-and-underflow"><h3>Overflow and underflow</h3></a>
<p>When doing arithmetic on numbers, sometimes the result is too large or small to be represented. For example if you add two 8 bit numbers 253 and 9 together you would expect to get 262. But 262 cannot be represented by 8 bits (it requires 9 bits). When this happens the number simply is what the first 8 bits of 262 would be just with the final 9th bit missing: 0b0000_0110 a.k.a 6. This phenomenon is called overflow. The opposite can occur when subtracting. This is called underflow</p>
<a class="header" href="#rust" id="rust"><h3>Rust</h3></a>
<p>In Rust, the various number types tell us both how many bits are used to represent that particular integer and whether the integer is in two's complement or not. For example, the number type <code>u8</code> is a number composed of 8 bits (i.e., 1 byte) and is unsigned while <code>i64</code> is a number composed of 64 bits (i.e., 8 bytes) and is signed.</p>
<a class="header" href="#number-notations" id="number-notations"><h1>Number Notations</h1></a>
<p>In this guide we'll deal with the various ways that we can think about and write down numbers.</p>
<a class="header" href="#number-notations-1" id="number-notations-1"><h2>Number Notations</h2></a>
<a class="header" href="#binary" id="binary"><h3>Binary</h3></a>
<p>The smallest amount of data that computers, including the Game Boy, deal with are bits. A bit is either one of two values. When we talk about bits we say that a bit is one of two distinct values: &quot;1&quot; or &quot;0&quot;. Bits in other words are &quot;binary&quot; (i.e. relating to, composed of, or involving two things - &quot;bi&quot; is a latin prefix meaning two).</p>
<p>So we can talk about bits by using either the symbol &quot;1&quot; or the symbol &quot;0&quot;. This way of talking about numbers is called &quot;binary notation&quot;. This is different from the way we normally talk about numbers where we have ten different possibilities composed of ten distinct symbols: &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, or &quot;9&quot; - a.k.a. decimal notation (&quot;deci&quot; is a latin prefix meaning ten). When talking binary we'll never need any other symbols besides &quot;0&quot; and &quot;1&quot;.</p>
<blockquote>
<p><strong>Side Note</strong></p>
<p>We don't <em>have</em> to use the symbols &quot;1&quot; and &quot;0&quot; for binary. People sometimes use other ways of representing the two distinct values including: &quot;yes&quot; or &quot;no&quot;, true or false, on or off, high or low, and more! In fact, computers normally represent bits as either one voltage (e.g. five volts) or as some other, typically lower, voltage (e.g. zero volts). Again, a great resource for learning about how computers actually deal with bits, check out Ben Eater's series on <a href="https://www.youtube.com/user/eaterbc">making an 8-bit Breadboard Computer</a>.</p>
</blockquote>
<p>So in binary notation we can represent the number zero with the symbol &quot;0&quot; and the number one with the symbol &quot;1&quot;. What if we want to represent the number two? We just said we don't have the symbol &quot;2&quot; in binary - we only have either &quot;1&quot; or &quot;0&quot;. Well let's think about what we do in our &quot;normal&quot; decimal system when we run out of symbols to use? In other words what happens when we're going from nine (represented by &quot;9&quot;) to ten? Well, we reset the first digit to &quot;0&quot; and add a new one starting with &quot;1&quot;  and we end up with &quot;10&quot; for ten.</p>
<p>This is exactly what we do in binary. So, to represent the number two, we reset the first digit to &quot;0&quot; and a &quot;1&quot; to the left of it. The number two is therefore &quot;10&quot;.</p>
<p>So what's the number three then? You guessed it! &quot;11&quot;. Let's count to ten in binary!</p>
<p>Zero   &quot;0&quot;
One    &quot;1&quot;
Two    &quot;10&quot;
Three  &quot;11&quot;
Four   &quot;100&quot;
Five   &quot;101&quot;
Six    &quot;110&quot;
Seven  &quot;111&quot;
Eight  &quot;1000&quot;
Nine   &quot;1001&quot;
Ten    &quot;1010&quot;</p>
<p>We can now count as high as we want in binary!</p>
<p>Since binary numbers can look an awful lot like decimal numbers, it's helpful to have a way to say &quot;this number is written in binary not in decimal!&quot;. A common way this is done (and how both we will do it in this book and how Rust also does it) is by prefixing numbers written in binary with &quot;0b&quot;. So, the number three would be written &quot;0b11&quot;</p>
<blockquote>
<p><strong>Side Note</strong></p>
<p>In order to avoid confusion, the best way to read binary numbers outloud (or in your head) is by reading each digit instead of using the decimal name for the number. So the number &quot;0b1001&quot; should either be read as &quot;nine&quot; or as &quot;one zero zero one&quot; never as &quot;one thousand and one&quot;.</p>
</blockquote>
<a class="header" href="#hexadecimal" id="hexadecimal"><h3>Hexadecimal</h3></a>
<p>One interesting and important thing to note is at what numbers we add an extra digit when using binary. Let's list them: two, four, eight, sixteen, etc. Can you spot the pattern? Each number is a power two! Another way to call a counting system that works like this is a &quot;base two&quot; counting system. Our decimal system on the other hand gains a digit at every number that is a power of ten - so it is a &quot;base ten&quot; counting system.</p>
<p>The natural question might arise: &quot;are there any other types of counting systems besides base two and base ten&quot;. And the answer is yes! While there are many different systems, the only other one we'll make use of in our emulator is hexadecimal - base sixteen!</p>
<p>So, base two has two different symbols and base ten has ten different symbols, which means base sixteen should have sixteen different symbols. And here they are: &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;. So, instead of writing &quot;10&quot; for ten, we would now write &quot;a&quot; and eleven would be &quot;b&quot; and so on. Once we run out of symbols (i.e. after fifteen - &quot;f&quot;), we do what we've always done: reset our number to &quot;0&quot; and add a digit. Sixteen is written &quot;10&quot;.</p>
<p>Just like how in binary, we use &quot;0b&quot; to make it obvious we're talking binary and not decimal, we use &quot;0x&quot;for hexdecimal. So &quot;0x18&quot; is twenty-four not eighteen.</p>
<a class="header" href="#bit-and-byte-manipulation" id="bit-and-byte-manipulation"><h1>Bit and Byte Manipulation</h1></a>
<p>In this guide, we'll be discussing bit and byte manipulation through different bit-wise operators. If you're a little rusty on bits, bytes, binary and hexadecimal, check out our <a href="./number_notations.html">guide on number notation</a> and our <a href="./numbers.html">guide on numbers</a></p>
<p>CPUs normally do very simple operations on their registers. Most of these operations should be familiar to everyone, but some involve manipulating the bits of a byte in some structured way. Let's take a look.</p>
<a class="header" href="#and-" id="and-"><h2>AND (&amp;)</h2></a>
<p>Bitwise AND (&amp;) is similiar to the boolean AND (&amp;&amp;) operator you're probably already familiar with except that it operates on each bit of a byte or set of bytes. It's important to remember that boolean values are equivalent to a single bit: 1 is true and 0 is false.</p>
<p>If we have two boolean values we already know how to AND them:</p>
<pre><code>true  &amp;&amp; true  == true
false &amp;&amp; true  == false
true  &amp;&amp; false == false
false &amp;&amp; false == false
</code></pre>
<p>For bitwise operators we simply do the same operation on the the bits of two numbers that are the same digit place. If we encounter a <code>1</code> and <code>1</code> it becomes <code>1</code>. All other combinations are <code>0</code>.</p>
<p>Let's take a look at an example:</p>
<pre><code>  1001
&amp; 1100
------
  1000
</code></pre>
<p>Of course, we can do the same thing with hexadecimal numbers. The best way to think of these when you're getting used to them is to convert the hexadecimal number to binary and then do the AND:</p>
<pre><code>  0x8  1000
&amp; 0x3  0011
------ ----
  0x0  0000
</code></pre>
<p>Bitwise AND is often used to get the value at a specific bit or byte number. For example, if you have a 4 byte value and you just want the value in the third byte position you can AND the number with another value that has zeros in every position but the thrid byte - this practice is known as &quot;bit masking&quot;.</p>
<a class="header" href="#or-" id="or-"><h2>OR (|)</h2></a>
<p>Just like bitwise AND, Bitwise OR (|) is similiar to the boolean OR (||) operator except that it operates on each bit of a byte or set of bytes.</p>
<p>If we have two boolean values we already know how to || them:</p>
<pre><code>true  || true  == true
false || true  == true
true  || false == true
false || false == false
</code></pre>
<p>Let's take a look at a bitwise example:</p>
<pre><code>  1001
| 1100
------
  1101
</code></pre>
<p>The same advice around hexadecimal applies for bitwise OR as it did for AND. When in doubt, convert to binary and go bit by bit.</p>
<p>Bitwise OR can be used to combine two binary values together. For example, if you want to be sure that a value has it's least signficant bit set to 1, you can OR it with 0b1.</p>
<a class="header" href="#shift--" id="shift--"><h2>Shift (&lt;&lt; &gt;&gt;)</h2></a>
<p>Bit shifting is the practice of moving bits in order to different digit positions.</p>
<p>To accomplish this first we look at the operator to see what direction we're going: <code>&lt;&lt;</code> for left and <code>&gt;&gt;</code> for right. We then take each bit and shift it over as many places as the number to the right of the operator tells us to. Any numbers that no longer fit (i.e. they've been shift off the edge of the number) disappear. All digit places that are left empty by the shifting get replaced by 0s.</p>
<p>Let's take a look at some examples:</p>
<pre><code>1001 &gt;&gt; 1 == 0100
1001 &gt;&gt; 2 == 0010
1001 &gt;&gt; 3 == 0001
1001 &gt;&gt; 4 == 0000

1101 &lt;&lt; 1 == 1010
1101 &lt;&lt; 2 == 0100
1101 &lt;&lt; 3 == 1000
1101 &lt;&lt; 4 == 0000
</code></pre>
<p>Again, if you have a number in hexadecimal notation, you can first convert it to binary and go bit by bit.</p>
<p>One thing bit shifting is used for is to get the values of certain bytes in a number composed of many bytes. For example, in the following snippet, we're trying to get the value of the most significant byte:</p>
<pre><code>0x1c74a3 &gt;&gt; 16 == 0x1c
</code></pre>
<a class="header" href="#resources" id="resources"><h1>Resources</h1></a>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
